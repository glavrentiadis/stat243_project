---
title: "test_CalcProbBin"
author: "Anh Mai Bui"
date: "December 5, 2018"
output: pdf_document
---
```{r}
#Inputs

 library(Deriv)
#g <- function(x) {
  #(3/sqrt(2*pi))*exp(-(x^2)/2)
#}

#Poisson(lambda=2)
#g <- function(x) {
  #pi*(2^x)*exp(-2)/factorial(x)
#}

#Exponential(lambda=5)
g <- function(x) {
  pi*5*exp(-5*x)
}

X <- c(0.2,15.2)
X <- sort(X)
#x_star <- runif(1,min = X[1], max = X[2])

  g_prime <- Deriv(g)
  update_H <- function(x) {log(g(x))}
  update_H_prime <- function(x) {g_prime(x)/g(x)}
  
  H <- sapply(X, update_H)
  H_prime <- sapply(X, update_H_prime) 
  
  
  z <- function(i) {
  (H[i+1]-H[i]-X[i+1]*H_prime[i+1]+X[i]*H_prime[i])/(H_prime[i]-H_prime[i+1])
  }
  Z <- c(-Inf,Inf)
  for (z_order in 1:length(X)-1) {
      Z <- append(Z,z(z_order),z_order)
    }
x_accept <- c()
length_accept <- 1
```


```{r}
#Note: added H, H_prime, Z as parameters to function
update_accept <- function(x_star, g, X, H, H_prime, Z) {

  l <- function(x,i) {
   if (x < X[length(X)] & x >= X[1]){ #x in [X[i],X_[i+1] 
      leval <- ((X[i+1]-x)*H[i] + (x-X[i])*H[i+1])/(X[i+1]-X[i])
    } else if (x == X[length(X)]) { 
      i <- i -1
      leval <- ((X[i+1]-x)*H[i] + (x-X[i])*H[i+1])/(X[i+1]-X[i])
    } else { #x < X[1] or x > X[k]
      leval <- -Inf
    }
   return(leval)
  }
  
  u <- function(x,i) {H[i] + (x-X[i])*H_prime[i]}

  z <- function(i) {
  (H[i+1]-H[i]-X[i+1]*H_prime[i+1]+X[i]*H_prime[i])/(H_prime[i]-H_prime[i+1])
  }
  w <- runif(1)
  
  i_star_x <- max(which.max(X[X<=x_star]),0)
  i_star_z <- length(Z[x_star>=Z])
  print(paste0("x_star is: ",x_star))
  print(paste0("X :",list(X)))
  print(paste0("Z is: ",list(Z)))
  print(paste0("i_star_x is: ", i_star_x))
  print(paste0("i_star_z is: ", i_star_z))
  print(paste0("L is: ",l(x_star,i_star_x)))
  print(paste0("U is: ",u(x_star,i_star_z)))

  if(w <= exp(l(x_star,i_star_x) - u(x_star,i_star_z))){
    x_accept[length_accept] <<- x_star
    length_accept <<- length_accept+1
    print(paste0("No update. New x_accept"))

  } else {
    #Update step
    
      X <- append(X, x_star,i_star_x)
      H <- append(H,update_H(x_star),i_star_x)
      H_prime <- append(H_prime,update_H_prime(x_star),i_star_x)
      
      if (x_star != X[1] & x_star != X[length(X)]){ #x_star outside other X
        Z[i_star_x+1] <- z(i_star_x) #Overwrite a z
        Z <- append(Z,z(i_star_x+1),i_star_x+1) #Append a new z
      } else {
        Z <- append(Z,z(i_star_z),i_star_z)
      }
      
      print(paste0("Abscissae is updated"))
      print(paste0("New H is updated"))
      print(paste0("New H_prime is updated"))
    
    
    if (w <= exp(log(g(x_star)) - u(x_star,i_star_z))) {
      x_accept[length_accept] <<- x_star
      length_accept <<- length_accept+1
      print(paste0("Update step is done. New x_accept"))
    }
  }
  X <<- X
  H <<- H
  H_prime <<- H_prime
  Z <<- Z
}
```

```{r}
CalcProbBin <- function(X,Z,H,H_prime){
  #CalcProbBin calculates the probabilities of each segment of the exponential distribution.
  #Input: 
  # X: numeric array with all the values where h and h' have been evaluated
  # Z: numeric array with the ordinates at the intersections of the piecewise exponential function u
  # H: numeric array with the evaluations of function h at the locations X
  # H_prime:  numeric array with the evaluations of the first derivative of h at locations X
  #Output:
  # Pcum: numeric array with the cumulative probability of each of each segment 
  # log_s: numeric array with the normalized elevations of log(s) at locations X
  
  #number of bins
  n_bin <- length(Z) -1
  
  #calculate area under each bin (proportional to probabilty)
  a_coef <- H - X*H_prime #intersect of each line seg. (log space)
  b_coef <- H_prime #slope of each line seg. (log space)
  P <- exp(a_coef)/b_coef*(exp(b_coef*Z[-1]) - exp(b_coef*Z[-(n_bin+1)]))
  #normalized probabilites
  Ptot <- sum(P)
  P <- P/Ptot
  #cumulative probabilites
  Pcum <- cumsum(P) 
  #normalized height of distributions
  log_s <- H -log(Ptot)
  
  return(list(Pcum = Pcum, log_s = log_s, Ptot = Ptot))
}
```


```{r}
#test_list <- rpois(50,lambda = 5)
x_star=1

X <- c(0,0.5,1,1.5)

for (x_star in test_list) {
  update_accept(x_star,g,X,H,H_prime,Z)
}
```

